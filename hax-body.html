<link rel="import" href="imports.html">

<!--
`hax-body`
A LRN element that will change the world.

@demo demo/index.html

@microcopy - the mental model for this element
 - body is effectively a body of content that can be manipulated in the browser. This is for other HAX elements ultimately to interface with and reside in. It is the controller of input and output for all of HAX as it exists in a document. body is not the <body> tag but we need a similar mental model container for all our other elements.
 -
 -

-->

<dom-module id="hax-body">
  <template>
    <style>
      :host {
        display: block;
        min-height: 2em;
        min-width: 2em;
      }
      ::-moz-selection {
        background-color: var(--hax-body-highlight, --paper-yellow-300);
        color: black;
      }
      ::selection {
        background-color: var(--hax-body-highlight, --paper-yellow-300);
        color: black;
      }
      vaadin-context-menu ::shadow vaadin-context-menu-overlay {
        background-color: white;
      }
    </style>
    <vaadin-context-menu>
      <template>
        <paper-listbox>
          <paper-item>First menu item</paper-item>
          <paper-item>Second menu item</paper-item>
        </paper-listbox>
      </template>
    <div id="bodycontainer">
      <slot id="body"></slot>
    </div>
    </vaadin-context-menu>
  </template>

  <script>
    Polymer({

      is: 'hax-body',

      properties: {
        /**
         * State of if we are editing or not.
         */
        editMode: {
          type: Boolean,
          value: false,
          reflectToAttribute: true,
          notify: true,
          observer: '_editModeChanged',
        },
      },
      ready: function(e) {
        // mutation observer that ensures state of hax applied correctly
        this._observer = Polymer.dom(this).observeNodes(function(info) {
          // if we've got new nodes, we have to react to that
          if (info.addedNodes.length > 0) {
            info.addedNodes.map((node) => {
              node.contentEditable = this.editMode;
              this.fire('hax-body-tag-added', {node: node});
            });
          }
          // if we dropped nodes via the UI (delete event basically)
          if (info.removedNodes.length > 0) {
            // handle removing items... not sure we need to do anything here
            info.addedNodes.map(function(node) {
              this.fire('hax-body-tag-removed', {node: node});
            });
          }
        });
      },
      /**
       * Allow filtered insert into the local DOM.
       */
      haxInsert: function(tag, content) {
        var tags = ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote'];
        // verify this tag is a valid one
        if (tag.includes(tag)) {
          var toLocal = document.createElement(tag);
          toLocal.innerHTML = content;
          // send this into the root, which should filter it back down into the slot
          Polymer.dom(this).appendChild(toLocal);
        }
        return false;
      },
      /**
       * Notice the change between states for editing.
       */
      _editModeChanged: function(newValue, oldValue) {
        // fire above that we have changed states so things can react if needed
        if (typeof oldValue !== typeof undefined) {
          this.fire('hax-body-state', {editMode: newValue});
          this._applyContentEditable(newValue);
        }
      },
      /**
       * Walk everything we find and either enable or disable editable state.
       */
      _applyContentEditable: function(status) {
        let children = Polymer.dom(this.$.body).getDistributedNodes();
        for (var i = 0, len = children.length; i < len; i++) {
          children[i].contentEditable = status;
        }
      },

    });
  </script>
</dom-module>
