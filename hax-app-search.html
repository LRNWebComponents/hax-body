<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../paper-card/paper-card.html">
<link rel="import" href="../paper-styles/paper-styles.html">
<link rel="import" href="../iron-list/iron-list.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="../elmsln-loading/elmsln-loading.html">
<link rel="import" href="hax-app-pagination.html">
<link rel="import" href="hax-app-search-inputs.html">

<!--
`hax-app-search`
 An element that brokers the visual display of a listing of material from an end point. The goal is to normalize data from some location which is media centric. This expects to get at least enough data in order to form a grid of items which are selectable. It's also generically implemented so that anything can be hooked up as a potential source for input (example: youtube API or custom in-house solution). The goal is to return enough info via fired event so that hax-manager can tell hax-body that the user selected a tag, properties, slot combination so that hax-body can turn the selection into a custom element / element injected into the hax-body slot.

@demo demo/index.html

@microcopy - the mental model for this element
 - hax-source - a backend that can supply items for selection by the user
 - hax-manager - controlling the UI for selection of something
 - hax-body - the text are ultimately we are trying to insert this item into
-->
<dom-module id="hax-app-search">
  <template>
    <style>
      :host {
        display: block;
      };
      paper-button.item-wrapper {
        margin: 0;
        padding: 0;
      }
      paper-card {
        padding: 0;
        margin: .5em;
        width: 15em;
        font-size: .8em;
        --paper-card-header: {
          max-height: 10em;
        }
      }
      @media screen and (min-width: 800px) {
        paper-card {
          font-size: .85em;
        }
      }
      #loading[hidden] {
        visibility: hidden !important;
        opacity: 0 !important;
        display: block !important;
      }
      .loading {
        width: 100%;
        z-index: 1000;
        opacity: .9;
        text-align: center;
        align-content: space-around;
        justify-content: center;
        position: absolute;
        background-color: white;
        padding: 0;
        margin: 0;
        display: flex;
        margin: 0 auto;
        visibility: visible;
        transition: visibility .5s, opacity .5s ease;
      }
      .loading elmsln-loading {
        margin: 0 5em;
        display: inline-flex;
      }
      #loading {
        height: 100%;
        display: flex;
        justify-content: center;
      }
      #loading .loading,
      #loading elmsln-loading{
        display: block;
        height: 5em;
      }
      .card-content {
        padding: .1em;
      }
      .card-content p {
        padding: 0;
        margin: 0;
      }
      #itemlist {
        overflow-y: unset !important;
      }

      hax-app-pagination {
        display: flex;
        justify-content: flex-end;
        justify-content: center;
      }
    </style>

    <iron-ajax
      auto=[[auto]]
      id="request"
      method="[[method]]"
      url="[[requestEndPoint]]"
      handle-as="json"
      headers="[[headers]]"
      params='[[requestParams]]'
      last-response="{{mediaList}}"
      hidden
      loading="{{loading}}"></iron-ajax>


    <div id="loading" class="loading" hidden$="[[!loading]]">
      <elmsln-loading color="blue-text text-darken-4" size="large"></elmsln-loading>
      <h3 class="loading-text">Loading content..</h3>
    </div>
    <hax-app-search-inputs label="[[label]]" schema="{{searchSchema}}" values="{{searchValues}}"></hax-app-search-inputs>
    <iron-list grid id="itemlist" items="[[media]]" as="preview">
      <template>
        <hax-app-search-result preview="[[preview]]"></hax-app-search-result>
      </template>
    </iron-list>

    <hax-app-pagination id="pagerbottom" pagination="[[pagination]]"></hax-app-pagination>
  </template>

  <script>
    Polymer({

      is: 'hax-app-search',
      properties: {
        /**
         * Active app globally bound based on previous selection.
         */
        activeApp: {
          type: Object,
          observer: '_resetAppSearch',
        },
        /**
         * Immediatley perform a request.
         */
        auto: {
          type: Boolean,
          value: false
        },
        /**
         * Search schema for presenting a form of input.
         */
        searchSchema: {
          type: Object,
          value: {},
        },
        /**
         * Search values for data binding between search input
         * and actually rebuilding the search request query
         */
        searchValues: {
          type: Object,
          value: {},
          observer: '_searchValuesChanged',
        },
        /**
         * loading
         */
        loading: {
          type: Boolean,
          value: false,
        },
        /**
         * Media object populated at the end
         */
        mediaList: {
          type: Object,
          value: {},
          observer: '_mediaListChanged',
        },
        /**
         * Media object, normalized.
         */
        media: {
          type: Array,
          value: [],
          observer: '_mediaChanged',
        },
      },
      /**
       * Search input was added.
       */
      _searchValuesChanged: function(newValue, oldValue) {
        if (typeof newValue !== typeof undefined) {
          console.log('time to update the input for the request');
          var requestParams = this.requestParams;
          for (var property in newValue) {
            requestParams[property] = newValue[property];
          }
          this.set('requestParams', {});
          this.set('requestParams', requestParams);
        }
      },
      /**
       * Active app has changed.
       */
      _resetAppSearch: function(newValue, oldValue) {
        if (typeof newValue !== typeof undefined) {
          let app = newValue;
          var requestParams = {};
          console.log(app);
          this.label = app.details.title;
          // disasble auto for a moment while we switch inputs
          this.auto = false;
          // see if we have any global settings for connections like api keys
          if (typeof app.connection.data !== typeof undefined) {
            requestParams = app.connection.data;
          }
          // see if the browse endpoint has local overrides
          if (typeof app.connection.operations.browse.data !== typeof undefined) {
            requestParams = Object.assign(requestParams, app.connection.operations.browse.data);
          }
          // ensure we overwrite completely
          this.set('requestParams', {});
          this.set('requestParams', requestParams);
          // build the request end point
          var requestEndPoint = app.connection.protocol + '://' + app.connection.url;
          // ensure we build a url correctly
          if (requestEndPoint.substr(requestEndPoint.length - 1) != '/') {
            requestEndPoint += '/';
          }
          // support local end point modification
          if (typeof app.connection.operations.browse.endPoint !== typeof undefined) {
            requestEndPoint += app.connection.operations.browse.endPoint;
          }
          this.set('requestEndPoint', requestEndPoint);

          // ensure correct wipe of the search area assuming it has a search
          this.set('searchSchema', {});
          if (typeof app.connection.operations.browse.search !== typeof undefined) {
            this.set('searchSchema', app.connection.operations.browse.search);
          }
          this.resultMap = app.connection.operations.browse.resultMap;
          // map pagination if it has it (it better..)
          this.set('pagination', {});
          if (typeof app.connection.operations.browse.pagination !== typeof undefined) {
            this.set('pagination', app.connection.operations.browse.pagination);
          }
          // reset the auto flag
          if (typeof app.connection.auto !== typeof undefined) {
            this.auto = app.connection.auto;
          }
          else {
            this.auto = true;
          }
        }
      },
      /**
       * Attached life cycle.
       */
      attached: function() {
        document.body.addEventListener('hax-store-property-updated', this._haxStorePropertyUpdated.bind(this));
      },
      /**
       * Store updated, sync.
       */
      _haxStorePropertyUpdated: function(e) {
        if (e.detail && typeof e.detail.value !== typeof undefined && e.detail.property) {
          this.set(e.detail.property, e.detail.value);
        }
      },
      /**
       * Callback for when media has been updated via the end point
       */
      _mediaListChanged: function(newValue, oldValue) {
        if (typeof newValue != {} && typeof oldValue !== typeof undefined) {
          let media = [];
          let map = this.resultMap;
          let data = [];
          // look for the items element to draw our data from at its root
          if (typeof this._resolveObjectPath(map.items, newValue) !== typeof undefined) {
            data = this._resolveObjectPath(map.items, newValue);
          }
          else {
            data = newValue;
          }
          // step through and translate response data into a form we can easily
          // understand when stamping out our cards above.
          for (i = 0; i < data.length; i++) {
            media[i] = {
              'id' : this._resolveObjectPath(map.preview.id, data[i]),
              'title': this._resolveObjectPath(map.preview.title, data[i]),
              'description': this._resolveObjectPath(map.preview.description, data[i]),
              'image' : this._resolveObjectPath(map.preview.image, data[i]),
              'type' : map.defaultGizmoType,
            };
            // gizmo type is also supported in the mapping element itself
            // Think an asset management backend as opposed to a specific
            // type of asset like video. If the item coming across can
            // effectively check what kind of gizmo is required for it
            // to work then we need to support that asset declaring the
            // gizmo type needed
            if (typeof map.gizmo.type !== typeof undefined) {
              media[i].type = this._resolveObjectPath(map.gizmo.type, data[i]);
            }
          }
          // this will trigger an aggressive repaint of the cards
          this.set('media', []);
          console.log(media);
          this.set('media', media);
        }
      },
      /**
       * Callback for when media has been processed for display
       */
      _mediaChanged: function(newValue, oldValue) {
        if (typeof oldValue !== typeof undefined) {
          (setTimeout(() => {
            this.$.itemlist.fire('iron-resize');
          }, 200))
        }
      },
      /**
       * Handle media item selected.
       */
      _itemSelected: function(e) {
        // user clicked something, normalize this
        var normalizedEvent = Polymer.dom(e);
        var local = normalizedEvent.localTarget;
        var detail = {};
        // url is the data-value on here
        let url = local.getAttribute('data-value');
        let gizmoType = local.getAttribute('data-gizmo-type');
        // sanity check
        if (url !== null && url !== '') {
          // @todo add support for other things from the source
          let props = {
            url: url
          };
          if (gizmoType === null || gizmoType === '') {
            gizmoType = Polymer.HaxStore.guessGizmoType(url);
          }
          let haxElement = Polymer.HaxStore.guessGizmo(gizmoType, props);
          if (typeof haxElement.tag !== typeof undefined) {
            Polymer.HaxStore.write('activeHaxElement', haxElement, this);
          }
          else {
            Polymer.HaxStore.toast("Sorry, I don't know how to handle that link yet.");
          }
        }
      },
      /**
       * Helper to take a multi-dimensional object and convert
       * it's reference into the real value. This allows for variable input defined
       * in a string to actually hit the deeper part of an object structure.
       */
      _resolveObjectPath: function(path, obj) {
        return path.split('.').reduce(function(prev, curr) {
            return prev ? prev[curr] : null
        }, obj || self);
      }
    });
  </script>
</dom-module>
